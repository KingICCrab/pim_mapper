<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>混合分区全局优化 ILP 模型 V2 - 详细解析</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.8;
            color: #333;
        }

        h1 {
            color: #1a5276;
            border-bottom: 3px solid #1a5276;
            padding-bottom: 10px;
        }

        h2 {
            color: #2874a6;
            border-bottom: 2px solid #2874a6;
            padding-bottom: 5px;
            margin-top: 40px;
        }

        h3 {
            color: #3498db;
            margin-top: 30px;
        }

        h4 {
            color: #5dade2;
        }

        .box {
            background: linear-gradient(135deg, #e8f4f8 0%, #d4e6f1 100%);
            border: 2px solid #2874a6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .important-box {
            background: linear-gradient(135deg, #fef9e7 0%, #fcf3cf 100%);
            border: 2px solid #f39c12;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .key-insight {
            background: linear-gradient(135deg, #eafaf1 0%, #d5f5e3 100%);
            border-left: 5px solid #27ae60;
            padding: 15px 20px;
            margin: 20px 0;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            border: 1px solid #bdc3c7;
            padding: 12px;
            text-align: left;
        }

        th {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tr:hover {
            background-color: #ebf5fb;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            color: #c0392b;
        }

        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 14px;
        }

        .formula {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            overflow-x: auto;
        }

        .toc {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .toc a {
            text-decoration: none;
            color: #2874a6;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        .section-num {
            color: #7f8c8d;
            margin-right: 10px;
        }

        @media print {
            body {
                font-size: 11pt;
            }

            .box,
            .important-box,
            .key-insight {
                break-inside: avoid;
            }
        }
    </style>
</head>

<body>

    <h1>混合分区全局优化 ILP 模型 V2</h1>
    <h2 style="border: none; color: #666; font-weight: normal;">完整数学建模与详细解析</h2>

    <div class="toc">
        <h3>目录</h3>
        <ol>
            <li><a href="#intro">引言与动机</a></li>
            <li><a href="#problem">问题建模</a></li>
            <li><a href="#variables">决策变量</a></li>
            <li><a href="#constraints">约束条件</a></li>
            <li><a href="#objective">目标函数</a></li>
            <li><a href="#compute">计算成本模型</a></li>
            <li><a href="#redist">层间数据流模型（核心）</a></li>
            <li><a href="#summary">完整模型总结</a></li>
        </ol>
    </div>

    <!-- ================================================================== -->
    <h2 id="intro"><span class="section-num">1.</span> 引言与动机</h2>
    <!-- ================================================================== -->

    <h3>1.1 全局分区问题</h3>

    <div class="key-insight">
        <strong>核心洞察</strong>：分区决策在层间<strong>不是独立的</strong>——第 \(l\) 层的输出分布直接影响第 \(l+1\) 层的输入分布。
    </div>

    <p>在神经网络加速器映射中，<strong>分区（Partition）</strong>指的是将计算分配到节点阵列中的多个处理单元。关键问题是：</p>
    <ul>
        <li>每层可以选择不同的分区方案</li>
        <li>但分区选择会影响相邻层之间的数据重分布成本</li>
        <li>因此需要<strong>全局优化</strong>而非逐层贪心</li>
    </ul>

    <h3>1.2 为什么需要混合分区？</h3>

    <p>nn_dataflow 框架通过 <code>PartitionScheme</code> 支持<strong>混合分区</strong>：</p>

    <pre>
PartitionScheme(
    order=(pe.OFMP, pe.BATP, pe.OUTP, pe.INPP),
    pdims=(PhyDim2(2,2), PhyDim2(2,2), PhyDim2(1,1), PhyDim2(1,1))
)
# 总节点数: 2×2 × 2×2 × 1×1 × 1×1 = 16 节点
</pre>

    <p>这允许<strong>同时</strong>在多个维度上进行分区：</p>

    <table>
        <tr>
            <th>维度</th>
            <th>符号</th>
            <th>含义</th>
            <th>传播影响</th>
        </tr>
        <tr>
            <td><strong>OUTP</strong></td>
            <td>\(K\)</td>
            <td>输出通道分区</td>
            <td>→ 下一层的 C 分布</td>
        </tr>
        <tr>
            <td><strong>OFMP</strong></td>
            <td>\(P \times Q\)</td>
            <td>输出特征图空间分区</td>
            <td>→ 下一层的空间分布 + Halo</td>
        </tr>
        <tr>
            <td><strong>BATP</strong></td>
            <td>\(N\)</td>
            <td>Batch 分区</td>
            <td>→ 通常层间一致</td>
        </tr>
        <tr>
            <td><strong>INPP</strong></td>
            <td>\(C\)</td>
            <td>输入通道分区</td>
            <td>→ 需要 All-Reduce</td>
        </tr>
    </table>

    <!-- ================================================================== -->
    <h2 id="problem"><span class="section-num">2.</span> 问题建模</h2>
    <!-- ================================================================== -->

    <h3>2.1 网络参数</h3>

    <p>考虑一个有 \(n\) 层的神经网络，对于每层 \(l \in \{1, ..., n\}\)：</p>

    <table>
        <tr>
            <th>符号</th>
            <th>含义</th>
        </tr>
        <tr>
            <td>\(K_l\)</td>
            <td>输出通道数（卷积核数量）</td>
        </tr>
        <tr>
            <td>\(C_l\)</td>
            <td>输入通道数</td>
        </tr>
        <tr>
            <td>\(H_l, W_l\)</td>
            <td>输入特征图的高度和宽度</td>
        </tr>
        <tr>
            <td>\(P_l, Q_l\)</td>
            <td>输出特征图的高度和宽度</td>
        </tr>
        <tr>
            <td>\(R_l, S_l\)</td>
            <td>卷积核的高度和宽度</td>
        </tr>
        <tr>
            <td>\(N\)</td>
            <td>Batch 大小（全局）</td>
        </tr>
    </table>

    <h3>2.2 硬件参数</h3>

    <table>
        <tr>
            <th>符号</th>
            <th>含义</th>
        </tr>
        <tr>
            <td>\(\text{Node}_H\)</td>
            <td>节点阵列高度维度</td>
        </tr>
        <tr>
            <td>\(\text{Node}_W\)</td>
            <td>节点阵列宽度维度</td>
        </tr>
        <tr>
            <td>\(\text{Node} = \text{Node}_H \times \text{Node}_W\)</td>
            <td>总节点数</td>
        </tr>
    </table>

    <h3>2.3 混合分区方案表示</h3>

    <div class="box">
        <h4>定义：混合分区方案</h4>
        <p>一个<strong>混合分区方案</strong> \(c\) 定义为每个维度的 2D 分区因子元组：</p>
        <div class="formula">
            \[c = \left\{ (p_d^h, p_d^w) : d \in \mathcal{D} \right\}\]
        </div>
        <p>其中 \(\mathcal{D} = \{\text{OUTP}, \text{OFMP}, \text{BATP}, \text{INPP}\}\) 是分区维度集合。</p>
    </div>

    <p><strong>节点约束</strong>：总使用节点数必须等于可用节点数：</p>
    <div class="formula">
        \[\prod_{d \in \mathcal{D}} (p_d^h \times p_d^w) = \text{Node}_H \times \text{Node}_W = \text{Node}\]
    </div>

    <h3>2.4 候选集生成</h3>

    <p>对于每层 \(l\)，生成候选分区集 \(\mathcal{C}_l\)，枚举所有有效的节点阵列因子分解：</p>

    <div class="formula">
        \[\mathcal{C}_l = \left\{ c : \prod_{d \in \mathcal{D}} (p_d^h \times p_d^w) = P \text{ 且 } c \text{ 对层 } l
        \text{ 有效} \right\}\]
    </div>

    <p>例如，对于 \(4 \times 4 = 16\) 节点阵列：</p>
    <pre>
16 = 16×1×1×1  (单维度分区)
   = 8×2×1×1   (两维度组合)
   = 4×4×1×1   
   = 4×2×2×1   (三维度组合)
   = 2×2×2×2   (四维度组合)
   = ...
</pre>

    <!-- ================================================================== -->
    <h2 id="variables"><span class="section-num">3.</span> 决策变量</h2>
    <!-- ================================================================== -->

    <h3>3.1 主决策变量</h3>

    <div class="box">
        <div class="formula">
            \[\boxed{x_{l,c} \in \{0, 1\}, \quad \forall l \in \{1,...,n\}, \; c \in \mathcal{C}_l}\]
        </div>
        <p><strong>语义解释</strong>：\(x_{l,c} = 1\) 当且仅当第 \(l\) 层选择混合分区方案 \(c\)。</p>
    </div>

    <h3>3.2 线性化辅助变量</h3>

    <p>目标函数中包含 \(x_{l,c_i} \cdot x_{l+1,c_j}\) 的二次项（表示相邻层分区选择的组合）。为了线性化，引入：</p>

    <div class="box">
        <div class="formula">
            \[\boxed{y_{l,c_i,c_j} \in [0, 1], \quad \forall l \in \{1,...,n-1\}, \; c_i \in \mathcal{C}_l, \; c_j \in
            \mathcal{C}_{l+1}}\]
        </div>
        <p><strong>语义解释</strong>：\(y_{l,c_i,c_j}\) 表示乘积 \(x_{l,c_i} \cdot x_{l+1,c_j}\)，仅当第 \(l\) 层使用方案 \(c_i\)
            <strong>且</strong>第 \(l+1\) 层使用方案 \(c_j\) 时等于 1。
        </p>
    </div>

    <!-- ================================================================== -->
    <h2 id="constraints"><span class="section-num">4.</span> 约束条件</h2>
    <!-- ================================================================== -->

    <h3>4.1 唯一性约束</h3>

    <p>每层必须<strong>恰好选择一个</strong>分区方案：</p>

    <div class="box">
        <div class="formula">
            \[\boxed{\sum_{c \in \mathcal{C}_l} x_{l,c} = 1, \quad \forall l \in \{1,...,n\}}\]
        </div>
    </div>

    <h3>4.2 线性化约束（McCormick 包络）</h3>

    <p>对于每对相邻层 \((l, l+1)\) 和所有方案组合 \((c_i, c_j)\)：</p>

    <div class="important-box">
        <h4>McCormick 包络约束</h4>
        <div class="formula">
            \[
            \boxed{
            \begin{aligned}
            y_{l,c_i,c_j} &\leq x_{l,c_i} \\
            y_{l,c_i,c_j} &\leq x_{l+1,c_j} \\
            y_{l,c_i,c_j} &\geq x_{l,c_i} + x_{l+1,c_j} - 1 \\
            y_{l,c_i,c_j} &\geq 0
            \end{aligned}
            }
            \]
        </div>
    </div>

    <p><strong>正确性证明</strong>：</p>
    <ul>
        <li>当 \(x_{l,c_i} = x_{l+1,c_j} = 1\)：约束给出 \(y \leq 1\), \(y \leq 1\), \(y \geq 1\)，所以 \(y = 1\) ✓</li>
        <li>当 \(x_{l,c_i} = 0\) 或 \(x_{l+1,c_j} = 0\)：第一或第二个约束给出 \(y \leq 0\)，所以 \(y = 0\) ✓</li>
    </ul>

    <!-- ================================================================== -->
    <h2 id="objective"><span class="section-num">5.</span> 目标函数</h2>
    <!-- ================================================================== -->

    <div class="box">
        <h4>最小化总成本</h4>
        <div class="formula">
            \[\boxed{
            \min \underbrace{\sum_{l=1}^{n} \sum_{c \in \mathcal{C}_l} \text{LayerCost}_l(c) \cdot
            x_{l,c}}_{\text{层内成本}}
            + \underbrace{\sum_{l=1}^{n-1} \sum_{c_i \in \mathcal{C}_l} \sum_{c_j \in \mathcal{C}_{l+1}}
            \text{Transition}_{l \to l+1}(c_i, c_j) \cdot y_{l,c_i,c_j}}_{\text{层间转换成本}}
            }\]
        </div>
    </div>

    <p>目标函数包含两个部分：</p>
    <ol>
        <li><strong>层内成本</strong> $\text{LayerCost}_l(c)$：每层在其选定分区下的计算和通信开销（只依赖当前层分区）</li>
        <li><strong>层间转换成本</strong> $\text{Transition}_{l \to l+1}(c_i, c_j)$：相邻层之间由于分区不匹配导致的数据重分布成本</li>
    </ol>

    <div class="important-box">
        <h4>成本分类原则</h4>
        <table>
            <tr>
                <th>类型</th>
                <th>依赖</th>
                <th>包含内容</th>
            </tr>
            <tr>
                <td><strong>层内成本</strong></td>
                <td>只依赖 \(c_i\)（当前层分区）</td>
                <td>计算、INPP All-Reduce、Halo 交换</td>
            </tr>
            <tr>
                <td><strong>层间转换成本</strong></td>
                <td>依赖 \((c_i, c_j)\)（相邻两层分区）</td>
                <td>K→C 重分布、空间重分布、Batch 重分布</td>
            </tr>
        </table>
    </div>

    <!-- ================================================================== -->
    <h2 id="compute"><span class="section-num">6.</span> 层内成本模型</h2>
    <!-- ================================================================== -->

    <div class="key-insight">
        <strong>层内成本</strong>：只依赖当前层的分区选择 \(c\)，包括计算成本和分区本身带来的通信开销。
    </div>

    <div class="box">
        <h4>层内成本组成</h4>
        <div class="formula">
            \[\boxed{\text{LayerCost}_l(c) = \text{Compute}_l(c) + R_C(c) + R_{\text{halo}}(c)}\]
        </div>
        <table>
            <tr>
                <th>成本项</th>
                <th>触发条件</th>
                <th>物理含义</th>
            </tr>
            <tr>
                <td>\(\text{Compute}_l(c)\)</td>
                <td>总是存在</td>
                <td>每节点的 MAC 计算量</td>
            </tr>
            <tr>
                <td>\(R_C(c)\)</td>
                <td>INPP > 1</td>
                <td>部分和的 All-Reduce 合并</td>
            </tr>
            <tr>
                <td>\(R_{\text{halo}}(c)\)</td>
                <td>OFMP > 1 且为卷积层</td>
                <td>从邻居 tile 获取边界数据</td>
            </tr>
        </table>
    </div>

    <h3>6.1 计算成本 \(\text{Compute}_l(c)\)</h3>

    <h4>基础计算量</h4>
    <p>第 \(l\) 层的基础 MAC（乘累加）操作数：</p>
    <div class="formula">
        \[\text{MACs}_l = N \times C_l \times K_l \times P_l \times Q_l \times R_l \times S_l\]
    </div>

    <h4>每节点工作量</h4>
    <p>采用混合分区 \(c\) 后，工作被分配：</p>
    <div class="formula">
        \[\text{Compute}_l(c) = \frac{\text{MACs}_l}{\text{Node}}\]
    </div>
    <p>其中 \(\text{Node} = \prod_{d \in \mathcal{D}} (p_d^h \times p_d^w)\) 是总节点数。</p>

    <div class="key-insight">
        <strong>关键理解</strong>：无论选择哪种分区方式，总计算量不变，每节点计算量都是 \(\text{MACs}_l / \text{Node}\)。
        分区方式的差异体现在<strong>通信成本</strong>上。
    </div>

    <h3>6.2 INPP All-Reduce 成本 \(R_C(c)\)</h3>

    <p>当使用输入通道分区 (INPP) 时，每个节点只计算部分输入通道的贡献，得到<strong>部分和</strong>：</p>

    <div class="box">
        <div class="formula">
            \[\boxed{R_C(c) = \begin{cases}
            0 & \text{if } p_{\text{INPP}} = 1 \\[8pt]
            O_l \times 2 \times \frac{p - 1}{p} & \text{if } p_{\text{INPP}} = p > 1
            \end{cases}}\]
        </div>
        <p>其中 \(O_l = N \times K_l \times P_l \times Q_l\) 是输出数据量。</p>
        <p>系数 2 来自 Ring All-Reduce：Reduce-Scatter + All-Gather，各需 \(\frac{n-1}{n} \times D\) 通信量。</p>
    </div>

    <h3>6.3 Halo Exchange 成本 \(R_{\text{halo}}(c)\)</h3>

    <p>当使用空间分区 (OFMP) 时，卷积层需要从邻居 tile 获取边界数据：</p>

    <div class="box">
        <p><strong>每个 tile 需要交换的 halo 数据量</strong>：</p>
        <div class="formula">
            \[\text{Halo}_{\text{per\_tile}} = N \times C_l \times \left[ 2 \times \text{halo}_h \times
            q_{\text{tile}} + 2 \times \text{halo}_w \times p_{\text{tile}} + 4 \times \text{halo}_h \times
            \text{halo}_w \right]\]
        </div>
        <p>其中：</p>
        <ul>
            <li>\(\text{halo}_h = \lfloor (R_l - 1) / 2 \rfloor\)：垂直方向 halo 宽度</li>
            <li>\(\text{halo}_w = \lfloor (S_l - 1) / 2 \rfloor\)：水平方向 halo 宽度</li>
            <li>\(p_{\text{tile}} = P_l / p_{\text{OFMP}}^h\)，\(q_{\text{tile}} = Q_l / p_{\text{OFMP}}^w\)</li>
        </ul>
    </div>

    <div class="formula">
        \[\boxed{R_{\text{halo}}(c) = \begin{cases}
        0 & \text{if } p_{\text{OFMP}}^h = p_{\text{OFMP}}^w = 1 \\[8pt]
        \text{Halo}_{\text{per\_tile}} & \text{if } p_{\text{OFMP}}^h > 1 \text{ or } p_{\text{OFMP}}^w > 1
        \end{cases}}\]
    </div>

    <div class="key-insight">
        <strong>Halo 的本质</strong>：
        <ul>
            <li>Halo 是<strong>输入数据</strong>，不是输出数据</li>
            <li>Halo 只增加<strong>通信量</strong>，不增加<strong>计算量</strong></li>
            <li>每个节点计算的输出像素数量固定为 \(p_{\text{tile}} \times q_{\text{tile}}\)</li>
        </ul>
    </div>

    <h3>6.4 层内成本总结</h3>

    <div class="important-box">
        <h4>完整层内成本公式</h4>
        <div class="formula">
            \[\boxed{\text{LayerCost}_l(c) = \frac{\text{MACs}_l}{\text{Node}} + R_C(c) + R_{\text{halo}}(c)}\]
        </div>
        <p><strong>物理意义</strong>：执行第 \(l\) 层所需的时间/能量，包括：</p>
        <ul>
            <li>计算时间（与 MACs 成正比）</li>
            <li>INPP 归约通信（如果有 INPP 分区）</li>
            <li>Halo 交换通信（如果有 OFMP 分区）</li>
        </ul>
    </div>

    <!-- ================================================================== -->
    <h2 id="redist"><span class="section-num">7.</span> 层间转换成本模型</h2>
    <!-- ================================================================== -->

    <div class="key-insight">
        <strong>层间转换成本</strong>：依赖相邻两层的分区选择 \((c_i, c_j)\)，描述从一层的输出分布到下一层期望的输入分布之间的数据重分布开销。
    </div>

    <h3>7.1 传播规则与转换成本的分离</h3>

    <div class="box">
        <h4>核心概念</h4>
        <p>对于相邻的两层 \(l\) 和 \(l+1\)：</p>
        <ol>
            <li><strong>传播规则</strong>（物理约束）：第 \(l\) 层的输出数据分布由其分区 \(c_i\) <strong>唯一确定</strong>
                <div class="formula">
                    \[\text{OutputDist}_l = f_{\text{prop}}(c_i) \quad \text{（不是选择，是事实）}\]
                </div>
            </li>
            <li><strong>输入需求</strong>：第 \(l+1\) 层的分区 \(c_j\) 决定其<strong>期望的输入分布</strong>
                <div class="formula">
                    \[\text{InputNeed}_{l+1} = g_{\text{need}}(c_j)\]
                </div>
            </li>
            <li><strong>转换成本</strong>：从实际分布到期望分布的通信开销
                <div class="formula">
                    \[\text{Transition}_{l \to l+1} = h_{\text{cost}}(\text{OutputDist}_l, \text{InputNeed}_{l+1})\]
                </div>
            </li>
        </ol>
    </div>

    <h3>7.2 三种传播维度</h3>

    <table>
        <tr>
            <th>维度</th>
            <th>传播规则（约束）</th>
            <th>转换成本（目标函数）</th>
        </tr>
        <tr>
            <td><strong>K→C</strong></td>
            <td>Layer \(l\) 的 OUTP 分区 → Layer \(l+1\) 的 C 分布</td>
            <td>当 OUTP\(^{(l)} \neq\) INPP\(^{(l+1)}\) 时产生 \(R_K\)</td>
        </tr>
        <tr>
            <td><strong>空间</strong></td>
            <td>Layer \(l\) 的 OFMP 分区 → Layer \(l+1\) 的空间分布</td>
            <td>当 OFMP\(^{(l)} \neq\) OFMP\(^{(l+1)}\) 时产生 \(R_{\text{spatial}}\)</td>
        </tr>
        <tr>
            <td><strong>Batch</strong></td>
            <td>Layer \(l\) 的 BATP 分区 → Layer \(l+1\) 的 batch 分布</td>
            <td>当 BATP\(^{(l)} \neq\) BATP\(^{(l+1)}\) 时产生 \(R_N\)</td>
        </tr>
    </table>

    <div class="important-box">
        <h4>总转换成本</h4>
        <div class="formula">
            \[\boxed{\text{Transition}_{l \to l+1}(c_i, c_j) = R_K(c_i, c_j) + R_{\text{spatial}}(c_i, c_j) + R_N(c_i,
            c_j)}\]
        </div>
        <table>
            <tr>
                <th>成本项</th>
                <th>触发条件</th>
                <th>物理含义</th>
            </tr>
            <tr>
                <td>\(R_K\)</td>
                <td>OUTP\(^{(l)} \neq\) INPP\(^{(l+1)}\)</td>
                <td>K 分布与 C 需求不匹配，需通信</td>
            </tr>
            <tr>
                <td>\(R_{\text{spatial}}\)</td>
                <td>OFMP\(^{(l)} \neq\) OFMP\(^{(l+1)}\)</td>
                <td>空间分布不匹配，需重分布</td>
            </tr>
            <tr>
                <td>\(R_N\)</td>
                <td>BATP\(^{(l)} \neq\) BATP\(^{(l+1)}\)</td>
                <td>Batch 分布不匹配，需通信</td>
            </tr>
        </table>
    </div>

    <h3>7.3 输出数据量</h3>

    <p>第 \(l\) 层需要传输的输出数据：</p>
    <div class="formula">
        \[O_l = N \times K_l \times P_l \times Q_l\]
    </div>

    <h3>7.4 K→C 传播与转换 (\(R_K\))</h3>

    <h4>传播规则（约束）</h4>
    <div class="box">
        <p>第 \(l\) 层的输出通道分区 (OUTP) <strong>决定</strong>了其输出数据的分布方式：</p>
        <div class="formula">
            \[\text{K\_Distribution}_l = p_{\text{OUTP}}^{(l)}\]
        </div>
        <p>这是物理事实，不是选择。第 \(l+1\) 层将此作为输入，其中：</p>
        <div class="formula">
            \[C_{l+1} = K_l \quad \text{（第 } l \text{ 层的输出通道数 = 第 } l+1 \text{ 层的输入通道数）}\]
        </div>
    </div>

    <h4>转换成本（目标函数项）</h4>
    <p>设 \(k = p_{\text{OUTP}}^{(l)}\) 为第 \(l\) 层的 K 分区因子（传播过来的分布），\(p = p_{\text{INPP}}^{(l+1)}\) 为第 \(l+1\) 层的 C
        分区因子（期望的分布）。</p>

    <div class="box">
        <div class="formula">
            \[R_K(c_i, c_j) = \begin{cases}
            0 & \text{if } k = 1 \text{ （K 完整，无需通信）} \\[8pt]
            0 & \text{if } k > 1 \text{ and } p = k \text{ （完美匹配）} \\[8pt]
            O_l \times \frac{k-1}{k} & \text{if } k > 1 \text{ and } p = 1 \text{ （All-Gather）} \\[8pt]
            O_l \times \frac{n-1}{n} & \text{if } k > 1 \text{ and } p \neq k \text{ （All-to-All）}
            \end{cases}\]
        </div>
        <p>其中 \(n = \max(k, p)\)。</p>
    </div>

    <div class="key-insight">
        <strong>关键理解</strong>：为什么 \(k=1\) 时成本为 0？
        <ul>
            <li>\(k=1\) 意味着第 \(l\) 层在 K 维度上<strong>不分区</strong></li>
            <li>每个节点持有<strong>完整的 K 通道</strong>输出（虽然可能是部分空间/batch）</li>
            <li>当 \(p > 1\) 时，第 \(l+1\) 层的每个节点只需要部分 C 通道</li>
            <li>由于 K 已经完整，每个节点可以<strong>本地选择</strong>它需要的 C 分区</li>
            <li><strong>不需要任何网络通信！</strong></li>
        </ul>
    </div>

    <table>
        <tr>
            <th>\(k\) (OUTP\(^{(l)}\))</th>
            <th>\(p\) (INPP\(^{(l+1)}\))</th>
            <th>通信模式</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>1</td>
            <td>任意</td>
            <td>None</td>
            <td>K 完整，本地选择即可</td>
        </tr>
        <tr>
            <td>&gt;1</td>
            <td>=k</td>
            <td>Match</td>
            <td>完美对齐，数据自然流动</td>
        </tr>
        <tr>
            <td>&gt;1</td>
            <td>1</td>
            <td>All-Gather</td>
            <td>收集分布的 K 数据到每个节点</td>
        </tr>
        <tr>
            <td>&gt;1</td>
            <td>≠k, ≠1</td>
            <td>All-to-All</td>
            <td>K 分布与 C 分区不匹配，需重分布</td>
        </tr>
    </table>

    <h3>7.5 空间传播与转换 (\(R_{\text{spatial}}\))</h3>

    <h4>传播规则（约束）</h4>
    <div class="box">
        <p>第 \(l\) 层的空间分区 (OFMP) <strong>决定</strong>了其输出特征图的空间分布：</p>
        <div class="formula">
            \[\text{Spatial\_Distribution}_l = (p_{\text{OFMP}}^{h,(l)}, p_{\text{OFMP}}^{w,(l)})\]
        </div>
        <p>每个节点持有输出特征图的一个 tile，这是物理事实。</p>
    </div>

    <h4>转换成本（目标函数项）</h4>
    <p>设 \((h_l, w_l) = (p_{\text{OFMP}}^{h,(l)}, p_{\text{OFMP}}^{w,(l)})\) 为传播过来的空间分布，\((h_{l+1}, w_{l+1})\) 为期望的空间分布。
    </p>

    <div class="formula">
        \[\boxed{R_{\text{spatial}}(c_i, c_j) = \begin{cases}
        0 & \text{if } (h_l, w_l) = (h_{l+1}, w_{l+1}) \\
        O_l \times \frac{n-1}{n} & \text{otherwise (All-to-All)}
        \end{cases}}\]
    </div>

    <p>其中 \(n = \max(h_l \times w_l, h_{l+1} \times w_{l+1})\)。</p>

    <h3>7.6 Batch 传播与转换 (\(R_N\))</h3>

    <h4>传播规则（约束）</h4>
    <div class="box">
        <p>第 \(l\) 层的 Batch 分区 (BATP) <strong>决定</strong>了其输出数据的 batch 分布：</p>
        <div class="formula">
            \[\text{Batch\_Distribution}_l = p_{\text{BATP}}^{(l)}\]
        </div>
    </div>

    <h4>转换成本（目标函数项）</h4>
    <p>Batch 分区通常在整个网络中保持一致，但如果传播分布与期望分布不同：</p>

    <div class="formula">
        \[\boxed{R_N(c_i, c_j) = \begin{cases}
        0 & \text{if } p_{\text{BATP}}^{(l)} = p_{\text{BATP}}^{(l+1)} \\
        O_l \times \frac{n-1}{n} & \text{otherwise (All-to-All)}
        \end{cases}}\]
    </div>

    <p>其中 \(n = \max(p_{\text{BATP}}^{(l)}, p_{\text{BATP}}^{(l+1)})\)。</p>

    <h3>7.7 精确通信成本公式</h3>

    <p>设 \(B\) 为单位数据的传输成本（bytes × 带宽倒数），\(L\) 为延迟：</p>

    <table>
        <tr>
            <th>操作</th>
            <th>精确通信量</th>
            <th>公式来源</th>
        </tr>
        <tr>
            <td><strong>All-Gather</strong></td>
            <td>\(\frac{n-1}{n} \times D\)</td>
            <td>每个节点发送 \(D/n\)，接收 \((n-1) \times D/n\)</td>
        </tr>
        <tr>
            <td><strong>Scatter</strong></td>
            <td>\(\frac{n-1}{n} \times D\)</td>
            <td>根节点发送 \(D\)，其他节点接收 \(D/n\)</td>
        </tr>
        <tr>
            <td><strong>All-to-All</strong></td>
            <td>\(\frac{n-1}{n} \times D\)</td>
            <td>每个节点发送/接收 \((n-1)/n\) 的数据</td>
        </tr>
        <tr>
            <td><strong>Ring All-Reduce</strong></td>
            <td>\(2 \times \frac{n-1}{n} \times D\)</td>
            <td>Reduce-Scatter + All-Gather，各 \(\frac{n-1}{n} \times D\)</td>
        </tr>
        <tr>
            <td><strong>Halo Exchange</strong></td>
            <td>\(2 \times (\text{halo}_h \times w + \text{halo}_w \times h) \times C\)</td>
            <td>与 4 个邻居交换边界（2D 网格）</td>
        </tr>
    </table>

    <div class="key-insight">
        <strong>关键</strong>：所有集合通信的数据量与节点数 \(n\) 相关，系数 \(\frac{n-1}{n}\) 来自于每个节点不需要"发给自己"。
    </div>

    <!-- ================================================================== -->
    <h2 id="summary"><span class="section-num">8.</span> 完整模型总结</h2>
    <!-- ================================================================== -->

    <div class="box">
        <h3>变量汇总</h3>
        <table>
            <tr>
                <th>类型</th>
                <th>变量</th>
                <th>范围</th>
                <th>数量</th>
            </tr>
            <tr>
                <td>主变量</td>
                <td>\(x_{l,c}\)</td>
                <td>\(\{0, 1\}\)</td>
                <td>\(O(nm)\)</td>
            </tr>
            <tr>
                <td>辅助变量</td>
                <td>\(y_{l,c_i,c_j}\)</td>
                <td>\([0, 1]\)</td>
                <td>\(O(nm^2)\)</td>
            </tr>
        </table>

        <h3>约束汇总</h3>
        <table>
            <tr>
                <th>类型</th>
                <th>约束</th>
                <th>数量</th>
            </tr>
            <tr>
                <td>选择约束</td>
                <td>\(\sum_{c} x_{l,c} = 1\)</td>
                <td>\(O(n)\)</td>
            </tr>
            <tr>
                <td>线性化约束</td>
                <td>\(y \leq x_1, y \leq x_2, y \geq x_1 + x_2 - 1\)</td>
                <td>\(O(nm^2)\)</td>
            </tr>
        </table>

        <h3>目标函数</h3>
        <div class="formula">
            \[\min \sum_{l} \sum_{c} \text{LayerCost}_l(c) \cdot x_{l,c} + \sum_{l} \sum_{c_i} \sum_{c_j}
            \text{Transition}_{l
            \to l+1}(c_i, c_j) \cdot y_{l,c_i,c_j}\]
        </div>

        <h3>成本模型汇总</h3>
        <table>
            <tr>
                <th>类型</th>
                <th>公式</th>
                <th>组成</th>
            </tr>
            <tr>
                <td>层内成本</td>
                <td>\(\text{LayerCost}_l(c)\)</td>
                <td>\(\text{Compute} + R_C + R_{\text{halo}}\)</td>
            </tr>
            <tr>
                <td>层间转换成本</td>
                <td>\(\text{Transition}_{l \to l+1}(c_i, c_j)\)</td>
                <td>\(R_K + R_{\text{spatial}} + R_N\)</td>
            </tr>
        </table>
    </div>

    <h3>复杂度分析</h3>
    <p>设 \(n\) 为层数，\(m\) 为每层最大候选方案数：</p>
    <ul>
        <li><strong>总变量数</strong>: \(O(nm^2)\)</li>
        <li><strong>总约束数</strong>: \(O(nm^2)\)</li>
        <li><strong>DP 替代方案</strong>: \(O(nm^2)\) 时间, \(O(nm)\) 空间</li>
    </ul>

    <h3>实际规模示例</h3>
    <p>对于 \(4 \times 4\) 节点阵列 (16 节点)：</p>
    <ul>
        <li>每层典型方案数: 30-100</li>
        <li>50 层网络: ~5000 主变量, ~250,000 辅助变量</li>
        <li>现代 ILP 求解器 (Gurobi, CPLEX) 可在秒级求解</li>
    </ul>

    <hr>
    <p style="text-align: center; color: #666;">
        混合分区全局优化 ILP 模型 V2<br>
        生成时间: 2024年
    </p>

</body>

</html>