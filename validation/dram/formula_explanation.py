"""
w_only R 循环 enter switch 公式详解
"""

print('=' * 80)
print('w_only R 循环 enter switch 公式详解')
print('=' * 80)
print()

print('【公式】')
print('  w_only enter switch = P_dram × (R_dram - 1) × n_w_crossing_Q')
print()

print('=' * 80)
print('【Step 1: w_only tile 在哪里？】')
print('=' * 80)
print()

R_dram, P_dram, Q_dram = 7, 28, 7
n_w_crossing_Q = 1  # 只有 q=3

print('w_only tile 定义: H 不跨越 block，W 跨越 block')
print()
print('循环结构 (从外到内): K -> C -> P -> Q -> R')
print()
print(f'w_only 分布:')
print(f'  - P: 所有 {P_dram} 个 P 值都可能有 w_only')
print(f'  - Q: 只有 {n_w_crossing_Q} 个 Q 值 (q=3) 是 w_crossing')
print(f'  - R: 大部分 r 值是 h_non (不跨越 H)')
print()

print('所以 w_only tiles 分布在:')
print(f'  {P_dram} 个 P × {n_w_crossing_Q} 个 Q = {P_dram * n_w_crossing_Q} 个 (P,Q) 组')
print()

print('=' * 80)
print('【Step 2: 每个 (P,Q) 组的 R 循环】')
print('=' * 80)
print()

print('对于固定的 (p, q=3):')
print('  R 循环遍历 r = 0, 1, 2, 3, 4, 5, 6')
print()
print('  每个 r 对应的 tile:')
print('    - 大部分是 w_only (H 不跨越)')
print('    - 最多 1 个是 both (H 跨越)')
print()

print('以 p=0, q=3 为例 (h_non P):')
print('  r=0: H=[0,1], 不跨越 => w_only')
print('  r=1: H=[1,2], 不跨越 => w_only')
print('  ...')
print('  r=6: H=[6,7], 不跨越 => w_only')
print('  全部 7 个都是 w_only')
print()

print('以 p=15, q=3 为例 (h_crossing P):')
print('  r=0: H=[30,31], 跨越 => both')
print('  r=1: H=[31,32], 不跨越 => w_only')
print('  ...')
print('  r=6: H=[36,37], 不跨越 => w_only')
print('  1 个 both + 6 个 w_only')
print()

print('=' * 80)
print('【Step 3: R 循环内部什么时候 switch？】')
print('=' * 80)
print()

print('关键: w_only tile 的 W 范围 = [24, 31]，跨越 block 0 和 block 1')
print()
print('每次访问 w_only tile:')
print('  1. 从 W=24 (block 0) 开始')
print('  2. 扫描到 W=31 (block 1) 结束')
print()
print('所以:')
print('  prev tile 的 last_block = (h, 1)   <- 结束在 W 的 block 1')
print('  curr tile 的 first_block = (h, 0)  <- 开始在 W 的 block 0')
print('  不相等 => switch')
print()

print('=' * 80)
print('【Step 4: 哪些转换会 switch？】')
print('=' * 80)
print()

print('R 循环: r=0 -> r=1 -> r=2 -> ... -> r=6')
print()
print('情况 A: 全是 w_only 的 P (如 p=0, 共 24 个 P)')
print('  r=0: w_only, 进入时从 q=2 来')
print('        q=2 的 W=[16,23], last_block=(h,0)')
print('        w_only 的 first_block=(h,0)')
print('        相等, 不 switch')
print()
print('  r=1: w_only, prev=w_only(r=0)')
print('        prev.last_block=(h,1)')
print('        curr.first_block=(h,0)')
print('        不相等, switch')
print()
print('  r=2..6: 同理, 每次都 switch')
print()
print('  switch 次数 = 6 (r=1,2,3,4,5,6)')
print()

print('情况 B: 有 both 的 P (如 p=15, 共 4 个 P)')
print('  r=0: both (不是 w_only, 不计入)')
print()
print('  r=1: w_only, prev=both(r=0)')
print('        both 的 last_block=(1,1)  <- H和W都在block 1')
print('        w_only 的 first_block=(1,0) <- H在block 1, W在block 0')
print('        不相等, switch')
print()
print('  r=2..6: prev=w_only, 同情况A, 每次都 switch')
print()
print('  switch 次数 = 6 (r=1,2,3,4,5,6)')
print()

print('=' * 80)
print('【Step 5: 公式推导】')
print('=' * 80)
print()

print('观察:')
print('  - 不管是情况 A 还是情况 B')
print('  - 每个 P 都产生 (R_dram - 1) = 6 次 switch')
print('  - 因为 r=0 进入时不 switch, r=1..6 每次都 switch')
print()

print('所以:')
print(f'  总 switch = P_dram × (R_dram - 1) × n_w_crossing_Q')
print(f'           = {P_dram} × {R_dram - 1} × {n_w_crossing_Q}')
print(f'           = {P_dram * (R_dram - 1) * n_w_crossing_Q} per KC')
print()
print(f'  × 12 KC = {P_dram * (R_dram - 1) * n_w_crossing_Q * 12}')
print(f'  实际: 2016 ✓')
print()

print('=' * 80)
print('【为什么 r=0 不 switch？】')
print('=' * 80)
print()

print('r=0 的前一个 tile 是 (p, q-1=2, r=6)')
print('  q=2 的 W 范围 = [16, 23]，完全在 block 0 内')
print('  所以 q=2 的 last_block = (h, 0)')
print()
print('w_only (q=3) 的 first_block = (h, 0)')
print()
print('两者相等，不需要 switch')
print()

print('=' * 80)
print('【直观理解】')
print('=' * 80)
print()

print('w_only tile 在 W 方向跨越 block:')
print('  每次访问: block 0 -> block 1')
print('  访问完后停在 block 1')
print()
print('下一个 tile (同 P, 同 Q, r+1):')
print('  又要从 block 0 开始')
print('  需要从 block 1 跳回 block 0')
print('  这就是 switch')
print()
print('R 循环共 7 次迭代:')
print('  第 1 次 (r=0): 从 q-1 进入, q-1 停在 block 0, 不需要跳')
print('  第 2-7 次 (r=1..6): 从 r-1 进入, r-1 停在 block 1, 需要跳回')
print()
print('所以 switch 次数 = 7 - 1 = 6 = R_dram - 1')
