"""
图解: 为什么 h_only 和 w_only 的进入 switch 率差异巨大
"""

print('=' * 80)
print('图解: 为什么 h_only 和 w_only 的进入 switch 率差异巨大')
print('=' * 80)
print()

print('【核心概念】')
print('进入 switch = prev_tile.last_block != curr_tile.first_block')
print()
print('循环顺序: K -> C -> P -> Q -> R(内)')
print('R 是最内层循环，意味着同一个 (p, q) 下会连续执行 r=0,1,2,...,6')
print()

print('=' * 80)
print('Case 1: h_only tile (进入 switch 率 25%)')
print('=' * 80)
print()

print('h_only tile 的特点:')
print('  - H 方向跨越 block 边界 (first_h_block ≠ last_h_block)')
print('  - W 方向不跨越 (first_w_block = last_w_block)')
print()

print('以 p=15, q=0 为例:')
print('  h_base = 15 × 2 = 30')
print()
print('  R 循环遍历 (h_only 在 r=0):')
print('+-----+----------+----------+---------+---------+---------+-----------+--------+')
print('| r   | H 范围   | H blocks | type    | first   | last    | prev.last | switch |')
print('+-----+----------+----------+---------+---------+---------+-----------+--------+')
print('| 0   | [30,31]  | [0,1]    | h_only  | (0,0)   | (1,0)   | -         | -      |')
print('| 1   | [31,32]  | [1,1]    | non     | (1,0)   | (1,0)   | (1,0)     | No     |')
print('| 2   | [32,33]  | [1,1]    | non     | (1,0)   | (1,0)   | (1,0)     | No     |')
print('| ... |          |          |         |         |         |           |        |')
print('| 6   | [36,37]  | [1,1]    | non     | (1,0)   | (1,0)   | (1,0)     | No     |')
print('+-----+----------+----------+---------+---------+---------+-----------+--------+')
print()

print('【关键观察】')
print('  h_only tile (r=0) 的 last_block = (1, 0)')
print('  下一个 non tile (r=1) 的 first_block = (1, 0)')
print('  相等！=> 不产生进入 switch')
print()

print('原因: h_only tile 的 last_block 在 H 方向的「后半部分」(h_block=1)')
print('       后续 non tiles 都在同一个 h_block=1 区域')
print()

print('进入 switch 只发生在:')
print('  - Q 循环边界 (q 从 6 回到 0，换了 w_block)')
print('  - P 循环边界 (p 从前一个值切换)')
print('  但这些边界跨越次数很少，所以进入 switch 率只有 25%')
print()

print('=' * 80)
print('Case 2: w_only tile (进入 switch 率 85.7%)')
print('=' * 80)
print()

print('w_only tile 的特点:')
print('  - W 方向跨越 block 边界 (first_w_block ≠ last_w_block)')
print('  - H 方向不跨越 (first_h_block = last_h_block)')
print()

print('以 p=0, q=3 为例:')
print('  q=3 时 W=[24, 31]，跨越 w_block 0 和 1')
print('  注意: R 循环改变 H，不改变 W')
print()
print('  R 循环遍历 (全都是 w_only):')
print('+-----+--------+----------+---------+---------+---------+-----------+--------+')
print('| r   | H 范围 | W 范围   | type    | first   | last    | prev.last | switch |')
print('+-----+--------+----------+---------+---------+---------+-----------+--------+')
print('| 0   | [0,1]  | [24,31]  | w_only  | (0,0)   | (0,1)   | (0,0)*    | No     |')
print('| 1   | [1,2]  | [24,31]  | w_only  | (0,0)   | (0,1)   | (0,1)     | YES    |')
print('| 2   | [2,3]  | [24,31]  | w_only  | (0,0)   | (0,1)   | (0,1)     | YES    |')
print('| ... |        |          |         |         |         |           |        |')
print('| 6   | [6,7]  | [24,31]  | w_only  | (0,0)   | (0,1)   | (0,1)     | YES    |')
print('+-----+--------+----------+---------+---------+---------+-----------+--------+')
print('* r=0 的 prev 是 q=2, r=6 的 tile，其 W=[16,23], last=(0,0)')
print()

print('【关键观察】')
print('  w_only tile (任何 r) 的 last_block = (h, 1)')
print('  下一个 w_only tile (r+1) 的 first_block = (h, 0)')
print('  不相等！=> 产生进入 switch')
print()

print('原因: w_only tile 的 last_block 在 W 方向的「后半部分」(w_block=1)')
print('       但每次重新进入时，first_block 从「前半部分」(w_block=0) 开始')
print()

print('r=0 不产生进入 switch 是因为:')
print('  前一个是 q=2 (W=[16,23])，last_block = (h, 0)')
print('  当前 q=3 的 first_block = (h, 0)')
print('  相等！=> 不产生进入 switch')
print()

print('=' * 80)
print('核心差异总结')
print('=' * 80)
print()
print('+----------+------------------------------------------------+------------------+')
print('| 类型     | R 循环内部连续 tile 的关系                     | 进入 switch 率   |')
print('+----------+------------------------------------------------+------------------+')
print('| h_only   | prev.last_h = curr.first_h (H 方向连续)        | 低 (25%)         |')
print('|          | W 不变 => prev.last == curr.first              | 大部分 No        |')
print('+----------+------------------------------------------------+------------------+')
print('| w_only   | H 方向改变，但同一 h_block 内                  | 高 (86%)         |')
print('|          | prev.last_w=1, curr.first_w=0                  | 大部分 Yes       |')
print('|          | => prev.last != curr.first                     |                  |')
print('+----------+------------------------------------------------+------------------+')
print()

print('=' * 80)
print('【本质原因】 - 最内层循环和 crossing 方向的关系')
print('=' * 80)
print()

print('R 是最内层循环，它改变 H 坐标（不改变 W 坐标）')
print()
print('h_only: 跨越发生在 H 方向')
print('  - R 循环改变 H，所以 prev 和 curr 在 H 方向是「连续」的')
print('  - h_only.last_h_block 通常 == 下一个 tile 的 first_h_block')
print('  - 结果: 进入 switch 很少发生')
print()
print('w_only: 跨越发生在 W 方向')
print('  - R 循环不改变 W，所以 W 方向的 block 分布是「固定的」')
print('  - w_only 的 first_w_block=0, last_w_block=1')
print('  - 每次从 w_only 到 w_only，prev.last=(h,1) != curr.first=(h,0)')
print('  - 结果: 进入 switch 几乎每次都发生（除了从 q-1 进入 q 的那次）')
print()

print('=' * 80)
print('【推论】如果 S 在最内层呢？')
print('=' * 80)
print()
print('如果 S 是最内层循环（改变 W 而不是 H）:')
print('  - h_only: prev.last_h 和 curr.first_h 不再连续 => 进入 switch 率会升高')
print('  - w_only: prev.last_w 和 curr.first_w 变得连续 => 进入 switch 率会降低')
print()
print('所以进入 switch 率取决于:')
print('  1. crossing 的方向 (H or W)')
print('  2. 最内层循环改变的方向 (R 改变 H, S 改变 W)')
print('  如果两者匹配，进入 switch 率低；不匹配，进入 switch 率高')
