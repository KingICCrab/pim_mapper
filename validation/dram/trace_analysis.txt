================================================================================
TRACE GENERATOR 问题分析
================================================================================

从 debug_small_output.txt 的数据：

MAPPING DETAILS:
  Level 0 (PE): H={Q:8, C:2}, W={P:4, K:4}, temporal={R:3, S:3, P:2}
  Level 1 (GlobalBuffer): 全是 1
  Level 2 (RowBuffer): 全是 1  
  Level 3 (LocalDRAM): temporal={C:8, K:4}
  
  Permutation:
    Level 0: R -> P -> S
    Level 3: K -> C

TRACE GENERATOR 的问题：

1. _build_dram_loop_structure 的逻辑:
   - 从 Level num_mems-1 到 Level 2 构建循环
   - 对于 'small' workload:
     - Level 3 有 C:8, K:4 -> 会生成 DRAM 循环
     - Level 2 全是 1 -> 不会生成循环
   
   所以 DRAM loops = [{dim=K, bound=4}, {dim=C, bound=8}]  
   (根据 permutation K -> C，K 在外层)

2. buffer_tile 计算 (_compute_buffer_tile_size):
   - Level 0: R=3, S=3, P=2, Q=8, C=2, K=4
   - Level 1: 全是 1
   - buffer_tile = {R:3, S:3, P:2, Q:8, C:2, K:4, N:1}

3. 问题出在 _generate_tile_accesses:
   
   对于每个 DRAM tile，它生成的是 buffer_tile 内的所有 Input 访问。
   
   Input tile 迭代的维度：
   - DIM_N: n0 到 n0+ns, ns=min(1, N-n0)=1
   - DIM_C: c0 到 c0+cs, cs=min(2, C-c0)=2
   - DIM_Q: q0 到 q0+qs, qs=min(8, Q-q0)=8
   - DIM_S: s0 到 s0+ss, ss=min(3, S-s0)=3
   - DIM_P: p0 到 p0+ps, ps=min(2, P-p0)=2
   - DIM_R: r0 到 r0+rs, rs=min(3, R-r0)=3
   
   每个 tile 内要访问的 input 元素数 (unique):
   h 范围: q*stride + s*dilation = [0,7]*1 + [0,2]*1 = [0..9] = 10 unique h
   w 范围: p*stride + r*dilation = [0,1]*1 + [0,2]*1 = [0..3] = 4 unique w
   (这是一个 tile 的 input footprint)
   
   但每个 (n,c) 只有 10×10=100 个元素，用 row_size=1024 的话：
   - Row 0: 地址 0-99 (100 元素)
   - 其他 row 不会被访问
   
   等等，让我重新看 trace 输出...
   
   从 trace 看：
   - Input 有 9 个 unique rows (row 0-8)
   - Input 有 900 unique addresses
   - N=1, C=16, H=10, W=10
   - 总 Input 大小 = 1×16×10×10 = 1600 元素
   
   用 row_buffer = 1024 bytes, element_size = 1 byte:
   - Row 0: 地址 0-1023
   - Row 1: 地址 1024-2047
   ...
   
   Input 1600 元素 -> 占用 row 0 (0-1023) 和 row 1 (1024-1599)
   
   但 trace 显示 9 个 unique rows 被访问！这意味着地址计算有问题。

================================================================================
地址计算分析
================================================================================

Input 地址计算 (_generate_tile_accesses):
```
h = indices[DIM_Q] * stride_h + indices[DIM_S] * dilation_h
w = indices[DIM_P] * stride_w + indices[DIM_R] * dilation_w

block_idx_h = h // block_h  # block_h = 10
block_idx_w = w // block_w  # block_w = 10
offset_h = h % block_h
offset_w = w % block_w

block_idx = block_idx_h * num_blocks_w + block_idx_w
# num_blocks_h = (10 + 10 - 1) // 10 = 1
# num_blocks_w = (10 + 10 - 1) // 10 = 1

# 如果 h < 10 且 w < 10，则 block_idx = 0

idx = (n * C + c) * nc_slice_stride + block_idx * input_block_stride + offset_in_block
```

对于 c=0 到 c=15:
- 每个 (n,c) slice 的起始地址 = c * nc_slice_stride

关键问题：nc_slice_stride 是怎么计算的？

从代码看：
```python
nc_slice_size = num_blocks_h * num_blocks_w * block_size
# = 1 * 1 * (10 * 10) = 100

if input_layout == "row_aligned":
    input_rb_tile_stride = ((input_rb_tile_size + row_size - 1) // row_size) * row_size
    if input_rb_tile_c == 1 and input_rb_tile_n == 1:
        nc_slice_stride = input_rb_tile_stride
```

input_rb_tile_c = mapping.get_tile_size(2, DIM_C) = Level 0+1+2 的 C 累积
从 tile sizes 看：Level 2 的 C 累积 = 3×3×2 中没有 C... 
实际上 Level 2 的 tile size 是 {R:3, S:3, P:2}，C 应该是从哪来的？

mapping.get_tile_size(level, dim) 返回到该 level 为止的累积 tile

从输出看：
  Tile Sizes (cumulative up to each level):
    Level 0: {'R': 3, 'S': 3, 'P': 2}
    Level 1: {'R': 3, 'S': 3, 'P': 2}
    Level 2: {'R': 3, 'S': 3, 'P': 2}
    Level 3: {'R': 3, 'S': 3, 'P': 2, 'C': 8, 'K': 4}

所以 input_rb_tile_c = mapping.get_tile_size(2, DIM_C) = 1 (没有 C)
input_rb_tile_n = mapping.get_tile_size(2, DIM_N) = 1

input_rb_tile_size = block_h * block_w * 1 * 1 = 10 * 10 = 100

因为 input_layout = "row_aligned":
input_rb_tile_stride = ((100 + 1024 - 1) // 1024) * 1024 = 1024

nc_slice_stride = 1024 (因为 input_rb_tile_c == 1 且 input_rb_tile_n == 1)

所以：
- c=0 的 Input 元素: 地址 0-99 (在 row 0)
- c=1 的 Input 元素: 地址 1024-1123 (在 row 1)
- c=2 的 Input 元素: 地址 2048-2147 (在 row 2)
- ...
- c=8 的 Input 元素: 地址 8192-8291 (在 row 8)

这解释了为什么有 9 个 unique rows！

每个 channel (c=0..15) 被放在单独的 row 中。

================================================================================
Row Activation 分析
================================================================================

DRAM Loops: K=4 (外层) -> C=8 (内层)
总迭代次数: 4 × 8 = 32 tiles

对于每个 tile (k_tile, c_tile):
  - c 范围: c_tile * 2 到 c_tile * 2 + 1 (因为 buffer_tile.C = 2)
  
  k_tile=0, c_tile=0: c=[0,1]  -> Input rows 0,1
  k_tile=0, c_tile=1: c=[2,3]  -> Input rows 2,3
  k_tile=0, c_tile=2: c=[4,5]  -> Input rows 4,5
  k_tile=0, c_tile=3: c=[6,7]  -> Input rows 6,7
  k_tile=0, c_tile=4: c=[8,9]  -> Input rows 8,9
  ...
  k_tile=1, c_tile=0: c=[0,1]  -> Input rows 0,1 (重新加载!)
  ...

因为 K 在外层，C 在内层，所以：
- 每次 K 迭代，会遍历所有 C tiles
- 共 4 次 K 迭代

Input 的 row activations 应该是：
- 每次 K 迭代需要重新加载所有 channel
- 4 次 K 迭代 × 8 个 C tiles × 2 channels/tile = 64 次 channel 加载

但实际上每个 channel 可能跨越多个 row (如果超过 row buffer)...

等等，让我重新计算：

实际情况：
- C=16 channels
- 每个 channel 100 元素 (10×10)
- nc_slice_stride = 1024 (row_aligned)
- 所以 c=0 在 row 0, c=1 在 row 1, ... c=15 在 row 15

但 buffer_tile.C = 2，每个 tile 只处理 2 个 channel

DRAM loops 是 C:8 意味着有 8 个 C tiles (16/2 = 8)

问题：在 _generate_tile_accesses 中，它是如何迭代 input 的？

它使用 visited_input 来去重，但问题是它在每个 tile 内迭代：

```
input_tile_sizes = {DIM_C: cs, ...}
cs = min(tile_size[DIM_C], workload.C - c0)
   = min(buffer_tile.C, C - c0)
   = min(2, 16 - c0) = 2
```

每个 tile 处理 2 个 channel。

但是，trace 里为什么会有 row thrashing？

让我看 sample trace：
- 0-29: Row 0, Col 0-29 (c=0 的一部分)
- 30-59: Row 1, Col 0-29 (c=1 的一部分)
- 60-69: Row 0, Col 30-39 (c=0 的另一部分) <- Row switch!
- 70-79: Row 1, Col 30-39 (c=1 的另一部分) <- Row switch!
...

这是在一个 tile 内部发生的！

问题在于 iterate_input 的迭代顺序：
input_order = sorted([N,C,Q,S,P,R], key=lambda d: -dim_perm_level[d])

从 mapping 看 permutation：
- Level 0: R(pos 0) -> P(pos 1) -> S(pos 2)
- Level 3: K(pos 0) -> C(pos 1)

所以 dim_perm_level:
- R: 0
- P: 1  
- S: 2
- K: 0 (Level 3)
- C: 1 (Level 3)
- Q, N: infinity (没有在 permutation 中)

sorted by -perm_level (outer to inner):
- Q: -inf -> 最外
- N: -inf -> 次外
- S: -2
- C: -1
- P: -1
- R: -0 -> 最内

input_order = [Q, N, S, C, P, R] (或 [N, Q, ...] 取决于 stable sort)

实际迭代顺序是 outer to inner，所以内层循环是 R，然后 P...

每个 tile 的迭代：
for q in range(8):      # Q 最外
  for n in range(1):    # N
    for s in range(3):  # S
      for c in range(2): # C
        for p in range(2): # P
          for r in range(3): # R 最内

h = q*1 + s*1 = q + s
w = p*1 + r*1 = p + r

当 q=0, s=0: h=0
当 q=0, s=1: h=1
当 q=0, s=2: h=2

所以每次 s 变化时，h 变化，但 c 是在 s 的内层...

让我 trace 一下：
q=0, n=0, s=0, c=0, p=0, r=0: h=0, w=0, addr=0*1024 + (0*10+0) = 0 (row 0)
q=0, n=0, s=0, c=0, p=0, r=1: h=0, w=1, addr=0*1024 + (0*10+1) = 1 (row 0)
q=0, n=0, s=0, c=0, p=0, r=2: h=0, w=2, addr=0*1024 + (0*10+2) = 2 (row 0)
q=0, n=0, s=0, c=0, p=1, r=0: h=0, w=1, addr=0*1024 + (0*10+1) = 1 (重复，skip)
q=0, n=0, s=0, c=0, p=1, r=1: h=0, w=2, addr=0*1024 + (0*10+2) = 2 (重复，skip)
q=0, n=0, s=0, c=0, p=1, r=2: h=0, w=3, addr=0*1024 + (0*10+3) = 3 (row 0)
q=0, n=0, s=0, c=1, p=0, r=0: h=0, w=0, addr=1*1024 + (0*10+0) = 1024 (row 1!) <- NEW ROW
...
q=0, n=0, s=1, c=0, p=0, r=0: h=1, w=0, addr=0*1024 + (1*10+0) = 10 (row 0) <- BACK TO ROW 0!

这就是 row thrashing 的原因！

在 iterate_input 的顺序中，C 在 S 的内层。
- 当 c 从 0 变到 1 时，row 从 0 变到 1
- 当 s 从 0 变到 1 时 (c 回到 0)，row 从 1 变回 0

这导致了频繁的 row switch。

================================================================================
根本原因
================================================================================

Trace generator 的 iterate_input 顺序基于 permutation level，
但这个顺序不一定对 row activation 最优。

具体问题：C 维度在 S 维度的内层迭代，
但 row_aligned 布局把每个 channel 放在不同的 row。
所以每次 s++ 时，c 从高回到低，导致 row 从高跳回低。

理想情况：应该把 C 放在更外层迭代，这样一次遍历所有 h,w 后再换 channel。

================================================================================
解决方案
================================================================================

方案 1：修改 trace generator 的 input 迭代顺序
  - 对于 row_aligned 布局，C 应该在最外层或靠外
  - 让 H/W (Q,S,P,R) 在 C 的内层完整迭代

方案 2：修改地址布局计算
  - 让同一 channel 的不同 H 位置在同一 row 内

方案 3 (最简单)：修改 iterate_input 的顺序
  - row_aligned 时，强制 C 在 Q,S,P,R 之前

我推荐方案 3，因为它最简单且符合 row_aligned 的语义。

