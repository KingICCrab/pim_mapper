"""解释 Input 滑动窗口导致 crossing 的原因"""

print("=== Input 滑动窗口访问模式 ===")
print()
print("卷积计算: 每计算一个 output pixel，需要访问一个 input 窗口")
print()

# 示例: 3x3 卷积, stride=1
print("例子: 3x3 卷积, stride=1, Input 6x6, Output 4x4")
print()
print("Output(q=0): 需要 Input[h=0:3]  -> 起始 h=0")
print("Output(q=1): 需要 Input[h=1:4]  -> 起始 h=1 (滑动)")
print("Output(q=2): 需要 Input[h=2:5]  -> 起始 h=2 (滑动)")
print("Output(q=3): 需要 Input[h=3:6]  -> 起始 h=3 (滑动)")
print()

# 图示
print("=" * 60)
print("Row-Aligned 布局 (block_h = 4):")
print("=" * 60)
print()
print("  h=0  ┌─────────┐ <-- Block 0 (DRAM row 0)")
print("  h=1  │         │")
print("  h=2  │         │")
print("  h=3  └─────────┘")
print("  h=4  ┌─────────┐ <-- Block 1 (DRAM row 1)")  
print("  h=5  │         │")
print("       └─────────┘")
print()

print("tile_h=3 (窗口高度), step=1 (滑动步长):")
print()
print("  访问 q=0: h=[0,1,2]   在 Block 0 内     -> 1 row activation")
print("  访问 q=1: h=[1,2,3]   在 Block 0 内     -> 1 row activation")
print("  访问 q=2: h=[2,3,4]   跨 Block 0,1      -> 2 row activations (CROSSING)")
print("  访问 q=3: h=[3,4,5]   跨 Block 0,1      -> 2 row activations (CROSSING)")
print()

print("=" * 60)
print("Crossing 判断公式:")
print("=" * 60)
print()
print("  crossing 发生当: (k * step) mod block_h + tile_h > block_h")
print()
print("  k=0: (0*1) mod 4 + 3 = 0 + 3 = 3 <= 4  -> 无 crossing")
print("  k=1: (1*1) mod 4 + 3 = 1 + 3 = 4 <= 4  -> 无 crossing")
print("  k=2: (2*1) mod 4 + 3 = 2 + 3 = 5 > 4   -> CROSSING")
print("  k=3: (3*1) mod 4 + 3 = 3 + 3 = 6 > 4   -> CROSSING")
print()
print("  crossing_ratio = 2/4 = 50%")
print()

print("=" * 60)
print("对比: Weight/Output vs Input")
print("=" * 60)
print()
print("Weight/Output:")
print("  - 每个 tile 访问是独立的")
print("  - 起始地址在地址空间中均匀分布 (随机)")
print("  - crossing 只取决于 tile_size vs DRAM_row_size")
print("  - 使用简单的 GCD 公式: crossing_ratio = f(tile_bytes, row_bytes)")
print()
print("Input:")
print("  - 滑动窗口访问模式!")
print("  - 连续的 tile 访问有固定的 step 关系")
print("  - crossing 取决于 (block_h, tile_h, step) 三者的关系")
print("  - 需要更复杂的公式: crossing_ratio = f(block_h, tile_h, step)")
print()

print("=" * 60)
print("为什么 block_h 重要?")
print("=" * 60)
print()
print("Row-Aligned 模式允许选择 block_h，可以优化 crossing:")
print()
print("  block_h=3 (= tile_h): 每个窗口恰好占一个 block")
print("    k=0: h=[0,1,2] in Block 0   -> 无 crossing")
print("    k=1: h=[1,2,3] 跨 Block 0,1 -> CROSSING")
print("    k=2: h=[2,3,4] 跨 Block 0,1 -> CROSSING")
print("    crossing_ratio = 66%  (更差!)")
print()
print("  block_h=6 (= H_in): 整个 input 在一个 block")
print("    所有访问都在 Block 0 内   -> 无 crossing")
print("    crossing_ratio = 0%   (最优!)")
print()
print("这就是为什么 ILP 需要选择最优的 block_h!")
