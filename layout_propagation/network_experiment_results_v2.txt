=== Network Layout Propagation Experiment Results (Updated) ===

Scenario: Conv1 (NCHW) -> ReLU (Insensitive) -> Conv2 (Blocked)

Objective: Determine where the layout transformation should occur.
- Option A: Conv1 -> [Transform] -> ReLU (Blocked) -> Conv2
- Option B: Conv1 -> ReLU (NCHW) -> [Transform] -> Conv2

Key Insight:
The decision now correctly accounts for the "Execution Cost" (Read/Write efficiency) of the ReLU node itself, because we force the Propagator to evaluate `select_strategy` even when layouts match.

Experiment 1: ReLU forced to use NCHW Loop Nest
- Result: ReLU adopted NCHW layout.
- Logic:
  - If ReLU adopts NCHW:
    - Conv1(NCHW) -> ReLU(NCHW): Cost ~2.0 (Direct Write, Perfect Match).
    - ReLU(NCHW) -> Conv2(Blocked): Cost ~9.58 (Transform on Write).
    - Total: ~11.58
  - If ReLU adopts Blocked:
    - Conv1(NCHW) -> ReLU(Blocked): Cost ~9.58 (Transform on Write).
    - ReLU(Blocked) -> Conv2(Blocked): Cost HIGH!
      - Why? Because ReLU is executing in NCHW loop order but reading/writing Blocked layout.
      - Read Cost (Blocked Layout, NCHW Loop) = High (Row Misses).
      - Write Cost (Blocked Layout, NCHW Loop) = High (Row Misses).
    - Total: > 20.0
  - Winner: NCHW Layout.
- Conclusion: Correct. If ReLU iterates in NCHW order, it should keep data in NCHW layout to avoid thrashing, and delay the transform until the end.

Experiment 2: ReLU forced to use Blocked Loop Nest
- Result: ReLU adopted BLOCKED layout.
- Logic:
  - If ReLU adopts NCHW:
    - Conv1(NCHW) -> ReLU(NCHW): Cost HIGH!
      - ReLU reads NCHW layout using Blocked Loop.
      - Read Cost (NCHW Layout, Blocked Loop) = High.
    - ReLU(NCHW) -> Conv2(Blocked): Cost ~9.58.
    - Total: > 20.0
  - If ReLU adopts Blocked:
    - Conv1(NCHW) -> ReLU(Blocked): Cost ~9.58 (Transform on Write).
    - ReLU(Blocked) -> Conv2(Blocked): Cost ~2.0 (Direct Write, Perfect Match).
    - Total: ~11.58
  - Winner: Blocked Layout.
- Conclusion: Correct. If ReLU iterates in Blocked order, it should receive data in Blocked layout (pay the transform cost early) so it can execute efficiently.

Final Verdict:
The Propagator now correctly balances "Transition Cost" vs "Execution Cost".
It successfully identifies that the optimal layout for an insensitive node depends on its execution schedule (Loop Nest).
